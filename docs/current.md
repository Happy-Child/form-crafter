разработать общие интерфейсы этих правил, условные блок как описывать через builder
- views, relations, valitions rules + в контексте подключения "плагинов". Какими они могут быть, плагины и нужны ли вообще?

- переименовать buidlers по типу данных

- container, repeater, editable, uploader, static. у editable обязательно value в схеме и функции создания модуля компонента

- Услования ваидации скрытых компонентов, для tab/accordion и показа ошибки на табе/шапке.

- Так нуэно скрывать компоненты для tabs или нет?



TODO описывать интефрейс правил обищй, и отдеблно каждого:
2. думал определить options builders и переименовать все чтобы было проще понять, можно ли сейчас сделать проще - value в зависимости от options.value (если есть)
3. Дальше думать над validation rule, какой интерфейс финальный для validate, как errors ставить и др. из todo в его директории.


- uniqueMerge. Нужно сделать builder который выбриает компонент/компоненты и которые являются братьями/сётрсами между собой. и возможно указание определённых типов компонента.
Видимо нужно фильтровать select при выборе первого компонента template, если это multiseelct.
Запрезщать выбирать эти компоненты в билдерах выбор компонента/-ов? Иначе юзер может выбрать так, что получим многомерный массив.

Регистрировать валидацию на форму в themeType (где собирается тема в объект)

// И как-то потом понимать, что есть оишбки на полях и не invalid=true
// ДЛЯ FORM VALIUD: продумать как будет устанавливаться error msg множественно в том числе и куда


Реализовать механизм данамич. создания компонентов из tempalte, потом вернуться в startsWithConditionOperator и изменить ctx, придумать общий опираясь на то, как изменился стор:
1. передалть хранение repeater полея, для наблюдения за их "value"
2. РЕАЛИЗОВАТЬ ФАБРИКИ ДЛЯ ХРАНЕИНЯ СХЕМ


// хук для получения rows по id

// СПЕРВА СДЕЛАТЬ ФАБРИК ОБЫЧНЫЙ ПОЛЕЙ, В ТОМ ЧИСЛЕ И В REPEATER (ДОЛЖНО РАБОТАТЬ ВСЁ ТАК ЖЕ КАК И РАНЬШЕ)
// ПОСЛЕ УЖЕ ДУМАТЬ НАД ФАБРИКАМИ ДЛЯ REPEATER

Занимался options builder: наверно нужно убирать output и давать выводить абсолютно всё что передаём в builder, а уже через отдельные типы выводить output значение. Не знаю.

После вернуться к реализации механизва relations, созданием графов с зависимыми и зависящими компонентами.



1. Механизм постройки графа зависимостей (без учёта диним. обновления графа):
Вывести просто граф где componenId: [depCompId, ...]

Граф корректен, если:
Все componentId, упомянутые в условиях правил, становятся ключами.
Все componentId, изменяемые правилами, добавляются в массивы значений соответствующих ключей.

2. Потологич. сортировка графа.
Даже при циклических зависимостях (например, field1 -> field2 -> field1) граф остаётся валидным, но требует обработки в сортировке.

3. Цикл обработать.

 
После этого вернуться к repeater проблемам, как запускать realtions rules? по событиями?

Кэш:
- Возврат значений при отмене правила. Если есть id в OverridesCache -> забираем оттуда данные, либо пустоту, и spread в объект из schema.


// TODO LAST
// СТРОИТЬ ГРАФ ОБХОДА, ОДИН ГРАФ ГОТОВ. НУЖНО СДЕЛАТЬ ОБРАТНЫЙ КАК МИНИМУМ, И ПОСМОТРЕТЬ ЧТО ПИСАЛ GROK (СОРТИРОВКА И ОБХОД). БЫЛИ ПРОБЛЕМЫ С ПРИОРИТЕТНЫМИ ЗАВИСИМОСТЯМИ И ПЕРЕКРЁСТНЫМИ (НЕ РЕКУРСИВНЫМИ)

